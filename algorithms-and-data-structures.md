1. [Алгоритмическая сложность](#1)
1. [Стэк vs Куча](#2)
1. [Двоичное дерево поиска](#3)
1. [Двоичная куча](#4)
1. [Быстрая сортировка](#5)
1. [Сортировка вставками](#6)
1. [Сортировка выбором](#7)
1. [Сортировка пузырьком](#8)
1. [Бинарный поиск](#9)
1. [Поиск в глубину](#10)
1. [Поиск в ширину](#11)
1. [LRU (least recently used)](#12)
1. [MRU (most recently used)](#13)
1. [Quadtree](#14)
1. [Красно-черное дерево](#15)

* **Алгоритмическая сложность**: <a name="1"></a>
    * **Константная O(1)**
    * **Логарифмическая О(log n)**
    * **Линейное O(n)**
    * **Линейно-логарифмическое (O(n log(n)))**
    * **Квадратическая (O(n<sup>2</sup>))**
* **Стэк vs Куча**: <a name="2"></a>
    * Стэк область память выделяемая в полном объеме, при создании процесса(Программы)
    * Для выделения память из кучи происходит обращение к ОС
* **Двоичное дерево поиска**: <a name="3"></a> Это двоичное дерево, обладающее дополнительными свойствами 
    * У всех узлов левого поддерева узла Х, значения меньше, чем у узла Х. 
    * У всех узлов правого поддерева узла Х, значения больше, чем у узла Х.
* **Двоичная куча**: <a name="4"></a> Это двоичное дерево, обладающее дополнительными свойствами 
    * Значение любого узла не меньше (или не больше), чем значения у его потомков.
    * Глубина всех узлов отличается не более, чем на 1 уровень.
    * Последний слой заполняется слева направо без пропусков.
* **Быстрая сортировка**: <a name="5"></a>
    * Выбрать из массива опорный элемент.
    * Взять два указателя, которые идут от начала и конца массива, до тех пор, пока не встретят элемент больше и меньше опорного.
    * Поменять элементы местами и продолжить следование, пока указатели не пересекутся.
    * При пересечении найдена позиция в массиве для опорного элемента.
    * Рекурсивно повторить алгоритм для правого и левого отрезка.
    * Алгоритмическая сложность - **линейно-логарифмическое (O(n log(n)))**, в худшем случае **квадратическая (O(n<sup>2</sup>))**, при выборе опорным наименьший, либо наибольший элемент.
* **Сортировка вставками**: <a name="6"></a>
    * В начале работы алгоритма, отсортированная последовательность пуста.
    * Поэлементно считываем массив и вставляем на нужную позицию в отсортированную последовательность.
    * Алгоритмическая сложность - в среднем **квадратичная**, в лучшем случае **линейная** (При уже отсортированном массиве).
    * Алгоритм можно улучшить, добавив бинарный поиск в момент вставки в отсортированную последовательность.
* **Сортировка выбором**: <a name="7"></a>
    * Проходим по всему массиву и находим наименьший элемент.
    * Меняем его с первым элементом массива, повторяем для оставшихся элементов.
    * Алгоритмическая сложность - **квадратичная**.
* **Сортировка пузырьком**: <a name="8"></a>
    * Итеративно проходим по массиву и меняем "пары" значений, до тех пор, пока они не будут отсортированы.
    * Алгоритмическая сложность: **квадратичная**.
* **Бинарный поиск**: <a name="9"></a>
* **Поиск в глубину**: <a name="10"></a>
* **Поиск в ширину**: <a name="11"></a>
* **LRU (least recently used)**: <a name="12"></a> Вытеснение давно неиспользуемых элементов. Реализуется, как вариант, очередью с приоритетами, при добавлении элемента в заполненную очередь, из неё убирается самый старый элемент. В таком виде сложность **логарифмическая**.
* **MRU (most recently used)**: <a name="13"></a>
* **Quadtree**: <a name="14"></a>
* **Красно-черное дерево**: <a name="15"></a>
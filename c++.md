1. [Оглавление](https://github.com/Nethius/cheatsheet/blob/main/README.md)
1. [Способы передачи аргументов в функцию](#1)
1. [Упакованные структуры](#2)
1. [RAII](#3)
1. [C++ style cast vs C style cast](#4)
1. [Placement new](#5)
1. [Размер пустого класса](#6)
1. [Таблицы виртуальных функций](#7)
1. [Абстрактный класс](#8)
1. [Ранее и позднее связывание](#9)
1. [Функторы/Лябмда-функции](#10)
1. [Ссылки vs указатели](#11)
1. [Правило трех/пяти](#12)
1. [Инстанцирование шаблона](#13)
1. [Частичная специализация шаблонов](#14)
1. [Полная специализация шаблона](#15)
1. [Static в с++](#16)
1. [Const в с++](#17)
1. [Исключения vs return codes](#18)
1. [Mutable](#19)
1. [Раскрутка стека](#20)
1. [ABI](#21)
1. [RTTI](#22)
1. [rvalue/lvalue](#23)
1. [SFINAE](#24)
1. [Публичное, приватное и протектед наследование](#25)
1. [Slicing](#26)
1. [PIMPL](#27)
1. [constexpr](#28)
1. [ADL](#29)
1. [Этапы компиляции](#30)
1. [std::forward](#31)
1. [variadic templates](#32)
1. [Корутины в с++](#33)
1. [Precompiled headers](#34)
1. [](#35)
1. [](#36)
1. [](#37)
1. [](#38)
1. [](#39)
1. [](#40)
1. [](#41)
1. [](#42)
1. [](#43)
1. [](#44)

* **Способы передачи аргументов в функцию**: <a name="1"></a>
    * T - передача по значению, создается копия объекта, которая и будет изменяться внутри функции, не затрагивая изначальнй объект.
    * T& - передача по ссылке, внутри функции будет использоваться изначальный объект.
    * const T& - тоже самое, но только read-only доступ.
    * T&& - передача по rvalue-ссылке, объект "перемещается" внутрь функции и перестает существовать снаружи.
* **Упакованные структуры**: <a name="2"></a> #TODO
* **RAII**: <a name="3"></a> Захват ресурса есть инициализация, инициализируем ресурс в конструкторе, освобождаем в деструкторе.
* **C++ style cast vs C style cast**: <a name="4"></a>
    * С++ style касты проще искать в коде, они безопаснее, потому что проверяют возможность преобразования типов. 
    * C style каст последовательно перебирает другие преобразования и применяет первый подходящий, что может привести к ошибкам.
    ``` c++
    const_cast
    static_cast
    static_cast followed by const_cast
    reinterpret_cast
    reinterpret_cast followed by const_cast
    ```
    * static_cast: 
        * Для преобразований простых типов, enum to int, int to float.
        * Для преобразований указателей и ссылок разных типов по иерархии наследования классов или преобразование к указателю на void.
        * Нелья преобразовывать значение к указателю или наоборот.
        * Проверка происходит на этапе компиляции. 
    * const_cast: Для добавления/удаления const и volatile квалификаторов 
    * dynamic_cast: 
        * Для преобразования указателя/ссылки базового класса к указателю наследника, с проверкой во время выполнения. Поскольку указатель может хранить как адрес наследника, так и базового класса (Понижающее приведение, не работает если наследование типа private или protected.).
    * reinterpret_cast: Для преобразования указателя к целому, указателя к указателю. Не снимает cv квалификаторы.
* **Placement new**: <a name="5"></a> Используется для инициализации (вызова конструктора) объекта в уже выделенной памяти.
* **Размер пустого класса**: <a name="6"></a> Равен одному байту, это сделано для того, чтобы у каждого объекта был свой уникальный адрес.
* **Таблицы виртуальных функций**: <a name="7"></a> Хранят в себе массив указателей на наиболее дочерние методы для данного класса. Для каждого класса содержащего виртуальные методы, создается своя таблица виртуальных функций. Базовый класс содержит указатель на таблицу. При наследовании, так же наследуется указатель на VTABLE, который будет указывать на таблицу наследника. Через указатель с типом базового класса, который указывает на экземпляр наследника, нельзя обратиться к специфичным методам наследника, но можно обратиться к переопределенным методам базового класса, используя указатель на VTABLE, поскольку он будет указывать на таблицу наследника и следовательно будут вызываться методы наследника. Абстрактные классы имеют таблицу, но указатели в ней будут нулевыми или ссылаться на функцию, которая выводит ошибку (__purecall?) 
* **Абстрактный класс**: <a name="8"></a> Класс, в котором определена чисто виртуальная функция. Что запрещает создавать экземпляр этого класса
* **Ранее и позднее связывание**: <a name="9"></a> 
    * Ранне связывание - означает, что вся необходимая информация для того, чтобы определить, какая именно функция будет вызвана, известна на этапе компиляции программы. В с++ - это стандартные вызовы функций.
    * Позднее связывание - означает, что объект связывается с функцией на этапе выполнения программы. В с++ достигается с помощью виртуальных функций.
* **Функторы/Лябмда-функции**: <a name="10"></a> #TODO
    * Функтор - это объект, который можно использовать подобно вызову функции, в с++ это достигается путем перегрузки оператора (). 
* **Ссылки vs указатели**: <a name="11"></a>
    * Ссылка должна быть проинициализирована при создании.
    * Указатель имеет свой адрес, который можно получить через оператор &.
    * С указателями работает арифметика указателей.
    * Указатель занимает память в зависимости от архитектуры платформы, ссылка не занимает память, так как не является объектом. Если значение ссылки нельзя узнать на этапе компиляции, то она реализуется как замаскированный указатель.
    * Ссылка как аргумент функции - замаскированный указатель.
    * Сколько места занимает ссылка:
        * В большинстве случаев - ничего не занимает, поскольку просто является псевдонимом другого объекта.
        * При передаче как параметр - #TODO
* **Правило трех/пяти**: <a name="12"></a> Если один из методов (конструктор, конструктор копирования, конструктор перемещения, оператор копирования, оператор перемещения, деструктор) определен программистом, то и остальные методы должны быть определены программистом.
* **Инстанцирование шаблона**: <a name="13"></a> Генерация кода шаблона с конкретными параметрами.
* **Частичная специализация шаблонов**: <a name="14"></a> Реализация шаблона с частичным указанием типов параметров.
* **Полная специализация шаблона**: <a name="15"></a> Реализация шаблона с явным указанием всех типов параметров шаблона. Рассматривается компилятором, как отдельный и независимый класс.
* **Static в с++**: <a name="16"></a>
    * Для статических элементов память выделяется только один раз и хранятся они в отдельном сегменте памяти. Например, статическая переменная созданная внутри функции будет сохранять свое значение между вызовами функции.
    * При объявлении статической функции/переменной в .cpp, мы говорим компилятору, что доступ к этой функции ограничен файлом, в котором она объявлена. (Пришло из Си).
    * При объявлении статической функции в .h, появляется возможность у каждого .cpp файла, который сделает инклюд этого .h,  иметь собственную реализацию этой функции.
    * Статические методы класса, используются без создания экземпляра класса, через оператор ::, могут обращаться только к статическим членам класса и статическим методам класса.
* **Const в с++**: <a name="17"></a>
    * Константные экземпляры класса могут явно вызывать только константные методы класса.
    * const int *ptr1 = &value; ptr1 указывает на "const int", поэтому это указатель на константное значение 
    * int *const ptr2 = &value; ptr2 указывает на "int", поэтому это константный указатель на неконстантное значение
    * const int *const ptr3 = &value; ptr3 указывает на "const int", поэтому это константный указатель на константное значение
* **Исключения vs return codes**: <a name="18"></a>
    * Исключения позволяют четко разделить обработку кода и обработку ошибок.
    * Необработанное исключение аварийно завершит программу.
    * Код ошибки не позволяет возвращать другой результат функции напрямую.
    * Нельзя возвращать код ошибки из операторов, конструкторов.
    * Обработка исключений более ресурсозатрано. В момент выброса исключения происходит раскрутка стека. #TODO
* **Mutable**: <a name="19"></a> 
    * Используется для переменных константного объекта класса. Например, для захвата мьютекса, внешне объект остается неизменным, но внутри нужно поменять его состояние. 
    * Для изменения переменных захваченных лямбда функциями по значению.
* **Раскрутка стека**: <a name="20"></a> При выбросе исключения, программа последовательно спускается на уровень ниже, к вызывающей функции, до тех пор, пока не найдет соответствующий обработчик исключения. При переходе на блок catch, вызываются деструкторы у всех объектов созданных на стеке, в обратном порядке их конструирования.
* **ABI**: <a name="21"></a> Application Binary Interface. Стандарт языка описывает, общее поведение, а ABI конкретную реализацию (как в памяти распалогаются классы, как распалагаются виртуальные таблицы и т.п.). Две библиотеки собранные с разным ABI нельзя слинковать вместе.
* **RTTI**: <a name="22"></a> (run-time type identification - RTTI) Используется для определения типа объекта, во время выполнения программы. Для этого используется функция typeid(объект).
* **rvalue/lvalue**: <a name="23"></a> [#TODO](https://ru.stackoverflow.com/a/863457)
* **SFINAE**: <a name="24"></a> Неудачная подстановка типов в шаблон, не является ошибкой, такие шаблоны отбрасываются и компилятор ищет дальше нужную перегрузку. Как пример, для одного типа данных используется вывод через cout, а для второго через print, можно сделать специализацию шаблона для каждого типа, но если потом будут добавляться новые типы данных, то нужно добавлять новые специализации. Тут на помощь приходит SFINAE, при определенном условии, для части типов будет выбираться нужная перегрузка. (enable_if)
* **Публичное, приватное и протектед наследование**: <a name="25"></a> #TODO
* **Slicing**: <a name="26"></a> #TODO
* **PIMPL**: <a name="27"></a> #TODO https://habr.com/ru/post/111602/
* **constexpr**: <a name="28"></a> #TODO
* **ADL**: <a name="29"></a> #TODO
* **Этапы компиляции**: <a name="30"></a> 
    * Препроцессинг - пропроцессор добавляет хэдеры в код, заменяет макросы их значениями, выбирает условия в #if  #ifdef  #ifndef.
    * Компиляция - превращает полученный код в ассемблерный код.
    * Ассемблирование - превращает полученный код в машинный код, сохраненный в объектный файл.
    * Линковка - связывает все объектные файлы и библиотеки в исполняемый файл. Таблица символов — это структура данных, создаваемая самим компилятором и хранящаяся в самих объектных файлах. Таблица символов хранит имена переменных, функций, классов, объектов и т.д., где каждому идентификатору (символу) соотносится его тип, область видимости. Также таблица символов хранит адреса ссылок на данные и процедуры в других объектных файлах.
* **std::forward**: <a name="31"></a> #TODO https://habr.com/ru/post/242639/
* **variadic templates**: <a name="32"></a> https://habr.com/ru/post/248897/
* **Корутины в с++**: <a name="33"></a> https://habr.com/ru/post/520756/ https://habr.com/ru/company/yandex_praktikum/blog/555704/
* **Precompiled headers**: <a name="34"></a> https://habr.com/ru/company/pvs-studio/blog/227521/
* ****: <a name="35"></a>  
* ****: <a name="36"></a>  
* ****: <a name="37"></a>  
* ****: <a name="38"></a>  
* ****: <a name="39"></a>  
* ****: <a name="40"></a>  
* ****: <a name="41"></a>  
* ****: <a name="42"></a>  
* ****: <a name="43"></a>  
* ****: <a name="44"></a>  
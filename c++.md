1. [Оглавление](README.md)
1. [Ключевые слова](#1)
    1. [Static в с++](#1.1)
    1. [Const в с++](#1.2)
    1. [Mutable](#1.3)
    1. [constexpr](#1.4)
    1. [auto и decltype](#1.5)
1. [Наследование]()
    1. [Таблицы виртуальных функций](#7)
    1. [Публичное, приватное и протектед наследование](#25)    
1. [Умные указатели]()
    1. [RAII](#3)
1. [STL]()
    1. [std::forward](#31)
    1. [Корутины в с++](#33)
1. [Исключения/обработка ошибок]()
    1. [Исключения vs return codes](#18)
    1. [Раскрутка стека](#20)
    1. [Исключения выброшенное в деструкторе](#38)
1. [Выделение памяти]()
    1. [Placement new](#5)
    1. [new() vs malloc()](#37)
1. [Классы/Структуры]()
    1. [Упакованные структуры](#2)
    1. [Размер пустого класса](#6)
    1. [Абстрактный класс](#8)
    1. [Правило трех/пяти](#12)
    1. [Explicit-конструктор](#35)
1. [Шаблоны]()
    1. [Инстанцирование шаблона](#13)
    1. [Частичная специализация шаблонов](#14)
    1. [Полная специализация шаблона](#15)
    1. [SFINAE](#24)
1. [Переменные/аргументы функций]()
    1. [Способы передачи аргументов в функцию](#1)
    1. [Ссылки vs указатели](#11)
    1. [rvalue/lvalue](#23)
1. [Компилятор]()
    1. [Ранее и позднее связывание](#9)
    1. [ADL](#29)
    1. [Этапы компиляции](#30)
1. [Всякое]()
    1. [C++ style cast vs C style cast](#4)
    1. [Функторы/Лябмда-функции](#10)
1. [ABI](#21)
1. [RTTI](#22)
1. [Slicing](#26)
1. [PIMPL](#27)
1. [variadic templates](#32)
1. [Precompiled headers](#34)

* **Ключевые слова**: <a name="1"></a>
    * **Static в с++**: <a name="1.1"></a>
        * Для статических элементов память выделяется только один раз и хранятся они в отдельном сегменте памяти. Например, статическая переменная созданная внутри функции будет сохранять свое значение между вызовами функции.
        * При объявлении статической функции/переменной в .cpp, мы говорим компилятору, что доступ к этой функции ограничен файлом, в котором она объявлена. (Пришло из Си).
        * При объявлении статической функции в .h, появляется возможность у каждого .cpp файла, который сделает инклюд этого .h,  иметь собственную реализацию этой функции.
        * Статические методы класса, используются без создания экземпляра класса, через оператор ::, могут обращаться только к статическим членам класса и статическим методам класса.
    * **Const в с++**: <a name="1.2"></a>
        * Константные экземпляры класса могут явно вызывать только константные методы класса.
        * const int *ptr1 = &value; ptr1 указывает на "const int", поэтому это указатель на константное значение 
        * int *const ptr2 = &value; ptr2 указывает на "int", поэтому это константный указатель на неконстантное значение
        * const int *const ptr3 = &value; ptr3 указывает на "const int", поэтому это константный указатель на константное значение
    * **Mutable**: <a name="1.3"></a> 
        * Используется для переменных константного объекта класса. Например, для захвата мьютекса, внешне объект остается неизменным, но внутри нужно поменять его состояние. 
        * Для изменения переменных захваченных лямбда функциями по значению.
    * **constexpr**: <a name="1.4"></a> #TODO
    * **auto и decltype**: <a name="1.5"></a>  
        * auto -
        * decltype - 
* **Наследование**: <a name=""></a>
    * **Таблицы виртуальных функций**: <a name="7"></a> Хранят в себе массив указателей на наиболее дочерние методы для данного класса. Для каждого класса содержащего виртуальные методы, создается своя таблица виртуальных функций. Базовый класс содержит указатель на таблицу. При наследовании, так же наследуется указатель на VTABLE, который будет указывать на таблицу наследника. Через указатель с типом базового класса, который указывает на экземпляр наследника, нельзя обратиться к специфичным методам наследника, но можно обратиться к переопределенным методам базового класса, используя указатель на VTABLE, поскольку он будет указывать на таблицу наследника и следовательно будут вызываться методы наследника. Абстрактные классы имеют таблицу, но указатели в ней будут нулевыми или ссылаться на функцию, которая выводит ошибку (__purecall?)
    * **Публичное, приватное и протектед наследование**: <a name="25"></a> #TODO
    * **Множественное наследование**: <a name=""></a>
* **Умные указатели**: <a name=""></a>
    * **RAII**: <a name="3"></a> Захват ресурса есть инициализация, инициализируем ресурс в конструкторе, освобождаем в деструкторе.
    * **unique_ptr**: <a name=""></a>
    * **shared_ptr**: <a name=""></a>
    * **weak_ptr**: <a name=""></a>
* **STL**: <a name=""></a>
    * **std::forward**: <a name="31"></a> #TODO https://habr.com/ru/post/242639/
    * **Корутины в с++**: <a name="33"></a> https://habr.com/ru/post/520756/ https://habr.com/ru/company/yandex_praktikum/blog/555704/
* **Исключения/обработка ошибок**: <a name=""></a>
    * **Исключения vs return codes**: <a name="18"></a>
        * Исключения позволяют четко разделить обработку кода и обработку ошибок.
        * Необработанное исключение аварийно завершит программу.
        * Код ошибки не позволяет возвращать другой результат функции напрямую.
        * Нельзя возвращать код ошибки из операторов, конструкторов.
        * Обработка исключений более ресурсозатрано. В момент выброса исключения происходит раскрутка стека. #TODO
    * **Раскрутка стека**: <a name="20"></a> При выбросе исключения, программа последовательно спускается на уровень ниже, к вызывающей функции, до тех пор, пока не найдет соответствующий обработчик исключения. При переходе на блок catch, вызываются деструкторы у всех объектов созданных на стеке, в обратном порядке их конструирования.
    * **Исключения выброшенное в деструкторе**: <a name="38"></a> 
        * Если в деструкторе будет блок try catch, который обработает это исключение, то все хорошо.
        * Если попали в деструктор во время раскрутки стека при уже выброшенном исключении и если в этот момент выбросить еще одно исключение, то будет вызвано std::terminate()
* **Выделение памяти**: <a name=""></a>
    * **Placement new**: <a name="5"></a> Используется для инициализации (вызова конструктора) объекта в уже выделенной памяти.
    * **new() vs malloc()**: <a name="37"></a>  
        * new() - оператор, malloc() - функция.
        * new() инициализирует память в 0, malloc() оставляет значение неопределенным.
        * new() вызывает конструктор объекта, malloc() просто выделяет память
* **Классы структуры**: <a name=""></a>
    * **Упакованные структуры**: <a name="2"></a> #TODO
    * **Размер пустого класса**: <a name="6"></a> Равен одному байту, это сделано для того, чтобы у каждого объекта был свой уникальный адрес.
    * **Абстрактный класс**: <a name="8"></a> Класс, в котором определена чисто виртуальная функция. Что запрещает создавать экземпляр этого класса
    * **Правило трех/пяти**: <a name="12"></a> Если один из методов (конструктор, конструктор копирования, конструктор перемещения, оператор копирования, оператор перемещения, деструктор) определен программистом, то и остальные методы должны быть определены программистом.
    * **Explicit-конструктор**: <a name="35"></a>  
* **Шаблоны**: <a name=""></a>
    * **Инстанцирование шаблона**: <a name="13"></a> Генерация кода шаблона с конкретными параметрами.
    * **Частичная специализация шаблонов**: <a name="14"></a> Реализация шаблона с частичным указанием типов параметров.
    * **Полная специализация шаблона**: <a name="15"></a> Реализация шаблона с явным указанием всех типов параметров шаблона. Рассматривается компилятором, как отдельный и независимый класс.
    * **SFINAE**: <a name="24"></a> Неудачная подстановка типов в шаблон, не является ошибкой, такие шаблоны отбрасываются и компилятор ищет дальше нужную перегрузку. Как пример, для одного типа данных используется вывод через cout, а для второго через print, можно сделать специализацию шаблона для каждого типа, но если потом будут добавляться новые типы данных, то нужно добавлять новые специализации. Тут на помощь приходит SFINAE, при определенном условии, для части типов будет выбираться нужная перегрузка. (enable_if)
* **Переменные/аргументы функций**: <a name=""></a>
    * **Способы передачи аргументов в функцию**: <a name=""></a>
        * T - передача по значению, создается копия объекта, которая и будет изменяться внутри функции, не затрагивая изначальнй объект.
        * T& - передача по ссылке, внутри функции будет использоваться изначальный объект.
        * const T& - тоже самое, но только read-only доступ.
        * T&& - передача по rvalue-ссылке, объект "перемещается" внутрь функции и перестает существовать снаружи.
    * **Ссылки vs указатели**: <a name="11"></a>
        * Ссылка должна быть проинициализирована при создании.
        * Указатель имеет свой адрес, который можно получить через оператор &.
        * С указателями работает арифметика указателей.
        * Указатель занимает память в зависимости от архитектуры платформы, ссылка не занимает память, так как не является объектом. Если значение ссылки нельзя узнать на этапе компиляции, то она реализуется как замаскированный указатель.
        * Ссылка как аргумент функции - замаскированный указатель.
        * Сколько места занимает ссылка:
            * В большинстве случаев - ничего не занимает, поскольку просто является псевдонимом другого объекта.
            * При передаче как параметр - #TODO
    * **rvalue/lvalue**: <a name="23"></a> [#TODO](https://ru.stackoverflow.com/a/863457)
* **Компилятор**: <a name=""></a>
    * **Ранее и позднее связывание**: <a name="9"></a> 
        * Ранне связывание - означает, что вся необходимая информация для того, чтобы определить, какая именно функция будет вызвана, известна на этапе компиляции программы. В с++ - это стандартные вызовы функций.
        * Позднее связывание - означает, что объект связывается с функцией на этапе выполнения программы. В с++ достигается с помощью виртуальных функций.
    * **ADL**: <a name="29"></a> #TODO
    * **Этапы компиляции**: <a name="30"></a> 
        * Препроцессинг - пропроцессор добавляет хэдеры в код, заменяет макросы их значениями, выбирает условия в #if  #ifdef  #ifndef.
        * Компиляция - превращает полученный код в ассемблерный код.
        * Ассемблирование - превращает полученный код в машинный код, сохраненный в объектный файл.
        * Линковка - связывает все объектные файлы и библиотеки в исполняемый файл. Таблица символов — это структура данных, создаваемая самим компилятором и хранящаяся в самих объектных файлах. Таблица символов хранит имена переменных, функций, классов, объектов и т.д., где каждому идентификатору (символу) соотносится его тип, область видимости. Также таблица символов хранит адреса ссылок на данные и процедуры в других объектных файлах.
* **Всякое**: <a name=""></a>
    * **C++ style cast vs C style cast**: <a name="4"></a>
        * С++ style касты проще искать в коде, они безопаснее, потому что проверяют возможность преобразования типов. 
        * C style каст последовательно перебирает другие преобразования и применяет первый подходящий, что может привести к ошибкам.
        ``` c++
        const_cast
        static_cast
        static_cast followed by const_cast
        reinterpret_cast
        reinterpret_cast followed by const_cast
        ```
        * static_cast: 
            * Для преобразований простых типов, enum to int, int to float.
            * Для преобразований указателей и ссылок разных типов по иерархии наследования классов или преобразование к указателю на void.
            * Нелья преобразовывать значение к указателю или наоборот.
            * Проверка происходит на этапе компиляции. 
        * const_cast: Для добавления/удаления const и volatile квалификаторов 
        * dynamic_cast: 
            * Для преобразования указателя/ссылки базового класса к указателю наследника, с проверкой во время выполнения. Поскольку указатель может хранить как адрес наследника, так и базового класса (Понижающее приведение, не работает если наследование типа private или protected.).
        * reinterpret_cast: Для преобразования указателя к целому, указателя к указателю. Не снимает cv квалификаторы.
    * **Функторы/Лябмда-функции**: <a name="10"></a> #TODO
        * Функтор - это объект, который можно использовать подобно вызову функции, в с++ это достигается путем перегрузки оператора (). 

* **ABI**: <a name="21"></a> Application Binary Interface. Стандарт языка описывает, общее поведение, а ABI конкретную реализацию (как в памяти распалогаются классы, как распалагаются виртуальные таблицы и т.п.). Две библиотеки собранные с разным ABI нельзя слинковать вместе.
* **RTTI**: <a name="22"></a> (run-time type identification - RTTI) Используется для определения типа объекта, во время выполнения программы. Для этого используется функция typeid(объект).
* **Slicing**: <a name="26"></a> #TODO
* **PIMPL**: <a name="27"></a> #TODO https://habr.com/ru/post/111602/
* **variadic templates**: <a name="32"></a> https://habr.com/ru/post/248897/
* **Precompiled headers**: <a name="34"></a> https://habr.com/ru/company/pvs-studio/blog/227521/
1. [Оглавление](README.md)
1. [Горутины](#1)
1. [Каналы](#2)
1. [Мапы](#3)
1. [Слайсы](#4)
1. [Массивы](#5)
1. [](#6)
1. [](#7)
1. [](#8)
1. [](#9)
1. [](#10)
1. [](#11)

* **Общее**: <a name="7"></a>
    * **Как реализовано ООП**: <a name="7"></a>
        * Инкапсуляция - реализована на уровне пакетов, приватные методы/свойства именуются с маленькой буквы, публичные с большой.
        * Полиморфизм - реализован с помощью ключевого слова interface
        * Наследование - как такового нет, но можно реализовать с помощью Embedding (встраивание), т.е. мы можем встраивать в структуру другие типы, в том числе другие структуры. При этом будут унаследованы и методы и свойства дочерних структур. Если в родительской и дочерней структуре есть методы с одинаковым именем, то для вызова метода дочерней структуры, нужно будет явно обратиться к нему через тип структуры (parent.Child.DoSomething()).
    * **Функция как параметр другой функции**: <a name="7"></a> 
    * **Замыкания (closures)**: <a name="7"></a> это функции, которые можно создавать в рантайме (?) и им будет доступны переменные области видимости, в которой они были созданы. Именованные/анонимные
    * **Как правильно создать проект**: <a name="7"></a> 
    * **Escape analysis**: <a name="7"></a>
    * **Как обрабатывать panic**: <a name="9"></a>
    * **Этапы компиляции**: <a name="9"></a>
        * Parsing (cmd/compile/internal/syntax) - исходники разбиваются на токены, создается синтаксическое дерево
        * Type-checking and Abstract Syntax Tree transformations (cmd/compile/internal/gc) - дерево переводится в AST, происходит проверки интерфейсов
        * Generic Static SIngle Assignment (cmd/compile/internal/gc, cmd/compile/internal/ssa) - AST переводится в SSA, применяются оптимизации, удаляются ненужные проверки 
        * Generating machine code (cmd/compile/internal/ssa, cmd/internal/obj) - опять происходят всякие оптимизации, перевод универсальных вещей в платформозависимые. Затем ассемблер генерирует машинный код и записывает в объектный файл.
    * **Дерективы компилятора**: <a name="9"></a>
    * **Type Switch**: <a name="9"></a>
    * **graceful shutdown**: <a name="9"></a>
    * **работа с указателями**: <a name="9"></a>
        * оператор & - взятие адреса переменной
        * оператор * - либо объявить тип указатель, либо для того, чтобы получить значение по адресу переменной
        * все параметры в go передаются по значению
* **Ключевые слова и встроенные функции**: <a name=""></a>
    * **new**: <a name="6"></a> встроенная функция, в качестве параметра ей передаётся тип, а возвращается указатель на новую переменную соответствующего типа.
    * **range**: <a name="6"></a>
    * **make**: <a name="6"></a>
    * **struct**: <a name="6"></a>
    * **interface**: <a name="6"></a> определяет набор сигнатур методов, но не представляет реализации.
    * **defer**: <a name="6"></a> 
        *функция отложенного вызова, выполняется всегда (даже в случае паники внутри вызываемой функции) после того, как функция завершила свое выполнение, но до того, как управление возвращается к вызывающей стороне. 
        * Функции c defer будут вызываться в обратной последовательности от их объявления во внешней функции.
        * Значения в defer передаются в момент вызова функции.
    * **select**: <a name="6"></a> позволяет обрабатывать несколько каналов "одновременно". 
        * Чтение - Блокируется, пока в один из каналов не попадет сообщение, если в оба канала сообщения пришли одновременно, то case будет выбран случайно. Если указана секция default, то при отсутствии сообщений, перестает быть блокируемым и выполнится код из секции default.
        * Запись - 
    * **fallthrough**: <a name="6"></a> Ключевое слово для работы с switch-case. Заставляет выполнять код в следующей объявленной булевой секции, вне зависимости подходит ли булевое условие case этой секции.
* **Многопоточность**: <a name=""></a>
    * **Горутины**: <a name="1"></a> это функция, выполняющаяся конкурентно с другими горутинами в том же адресном пространстве. Запускается с помощью ключевого слова go имя функции (или замыкание). 
        * В отличии от потоков, обрабатываются собственным планировщиком go и имеет стэк, размер которого может расти.
        * Минимальный размер стэка горутины 2 КБ, максимальный зависит от архитектуры, 1 ГБ для х64, 250 МБ для х32.
        * Если размер стэка привышен, то приложение упадет с fatal error.
        * Завершить горутину можно с помощью канала, переданного в горутину, который будет сообщать, когда нужно её закрыть или при помощи context.Context.
    * **Каналы**: <a name="2"></a> это структура данных, которая используется как объект связи, работает по принципу FIFO. 
        * Создается с помощью ключевого слова chan: channel := make(chan int), для чтения data := <-channel, для записи channel <- data, для закрытия close(channel). 
        * Запись в закрытый канал и повторное закрытие канала, приведет к панике. Запись/чтение в неинициализированный канал приведет к дедлоку
        * Буферизированные - создается указанием второго аргумента channel := make(chan int, 5), что является размером канала. В этом случае горутина не блокируется, пока канал не будет заполнен.
        * Небуферизированные - чтение или запись данных блокирует горутину и передает управление свободной горутине.
    * **Планировщик в Go**: <a name="7"></a> 
        * Неявная кооперативность. 
        * В одном потоке, в один момент времени, выполняется одна горутина, при этом в очереди исполнения их может быть неограниченное количество.
* **Структуры и типы данных**: <a name=""></a>
    * **Мапы**: <a name="3"></a> Неупорядоченная коллекция пар вида ключ-значение. Ключем может быть любой тип, который можно сравнить с помощью операторов сравнения. Структура может быть ключом до тех пор, пока её поля содержат только те типы, которые можно сравнивать. Если писать в не инициализированную мапу, то будет паника. Не потокобезопасна.
    * **Слайсы (срезы)**: <a name="4"></a> Упорядоченная структура данных. Реализуется поверх массива и представляет собой указатель на массив, длину (len) и емкость (cap). Может менять свой размер, динамическая аллокация памяти. При выходе за границу емкости, будет создан новый массив большей длины и произойдет копирование данных.
        * Увеличении размера слайса (метод growslice) происходит по следующему алгоритму — если его размер менее 1024 элементов, то его размер будет увеличиваться вдвое; иначе же слайс увеличивается на ~12.5% от своего текущего размера.
    * **Массивы**: <a name="5"></a> это последовательность фиксированной длины, состоящая из элементов одного типа. 
        * Размер массива является частью типа, [3]int и [5]int относятся к разным типам.
        * Доступ - константная сложность O(1).
        * При выходе за пределы массива сработает паника.
    * **string**: <a name="5"></a> является слайсом байт, доступным только для чтения, при сложении строк результатом будет новая строка. При подсчете длины строки, важно понимать, что количество байт != количеству символов.
    * **rune**: <a name="5"></a> интерпретирует массив байт, как массив символов. var r = 'f' - тип rune, var r = "f" - тип string.
    * **const и untyped**: <a name="5"></a>
* **Библиотека sync**: <a name="6"></a>
    * sync.Mutex - мьютекс как мьютекс
    * sync.RWMutex - Шаред мьютекс (read-write mutex), обладает доп. методами RLock() и RUnlock(), которые используются для блокировки только для чтения.
    * sync.Map - предоставляет атомарный доступ к элементам map.
    * sync.WaitGroup - это реализация счетчика, который можно инкрементировать и декрементировать, и самое главное остановить выполнение куска кода до того момента, пока значение счетчика не будет равно 0.
    * sync.Cond - Условная переменная (condition variable) - 
    * sync.Once - Позволяет определить задачу для однократного выполнения за всё время работы программы. Содержит одну-единственную функцию Do, позволяющую передавать другую функцию для однократного применения.
* **Библиотека context**: <a name="8"></a>
    * **context.Context**: <a name="9"></a>
* **Тестирование/профилирование**: <a name="9"></a>
    * **go test**: <a name="9"></a>
    * **go tool pprof**: <a name="9"></a>
* **Сборщик мусора в Go**: <a name="10"></a>
* ****: <a name="11"></a>
1. [Оглавление](README.md)
1. [ООП](#1)
1. [SOLID](#2)
1. [Порождающие паттерны](#3)
1. [Структурные паттерны](#4)
1. [Поведенческие паттерны](#5)
1. [Идиомы](#6)
1. [MVC](#7)
1. [Внедрение зависимости (Dependency injection, DI)](#8)
1. [](#9)
1. [](#10)
1. [](#11)

* **ООП**: <a name="1"></a>
    * **Абстракция** - обобщение без конкретики, выделение существенных свойств и связей.
    * **Полиморфизм** - объекты разных типов имеют одинаковый интерфейс использования, но различную реализацию.
    * **Инкапсуляция** - объединение данных и методов, работающих с ними в одном компоненте. Так же разграничивает доступ к свойствам компонента, если данные или методы должны быть доступны "извне", то объявляем их публичными, если нет, то приватными.
    * **Наследование** - механизм, позволяющий описывать новый класс на основе существующего
* **SOLID**: <a name="2"></a> #TODO https://habr.com/ru/company/1cloud/blog/522258/
    * **Какой профит?** - 
    * **Single Responsibility Principle** - у класса должна быть только одна причина для изменения
    * **Open-Closed Principle** - должна быть возможность расширить класс без его изменения (например, обертку для класса или сделать наследника). Т.е. должна быть возможность добавления новой функциональности, без изменения исходной логики модуля.
    * **Liskov Substitution Principle** - поведение наследующих классов не должно противоречить поведению, заданному базовым классом, то есть поведение наследующих классов должно быть ожидаемым для кода
    * **Interface Segregation Principle** - слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы программные сущности маленьких интерфейсов знали только о методах, которые необходимы им в работе
    * **The Dependency Inversion Principle** - Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций
* **Порождающие паттерны**: <a name="3"></a> описывают то, как создавать объекты без внесения в программу лишних зависимостей.
    * Factory Method - предлагает создавать объекты не напрямую, а через вызов особого метода, внутри которого взависимости от внешних параметров, будет создаваться экземпляр класса. Помогает, когда заранее неизвестен тип объекта, с которым будет работать дальнейший код. (Пример с различными модемами.)
    * Abstract Factory - 
    * Builder - 
    * Prototype - 
    * Singleton - гарантирует, что у класса есть только один экземпляр и предоставляет к нему глобальную точку доступа.
* **Структурные паттерны**: <a name="4"></a> описывают различные способы посторения связей между объектами.
    * Adapter - это объект проводник, который позволяет работать между собой нескольким классам, с несовместимыми интерфейсами, трансформируя интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту. (Например один класс работает с xml, второй с json)
    * Bridge - 
    * Composite - 
    * Decorator - объект обертка, который помимо вызова базовой функциональности, выполняет какие-то дополнительные действия.
    * Facade - простой интерфейс для работы с более сложной подсистемой. Может иметь урезанный интерфейс, не имеющей всех функиональности, которую можно достичь используя сложную подсистему, но предоставляет все фичи, которые нужны клиенту и скрывает от него все остальное.
    * Flyweight - 
    * Proxy -  
* **Поведенческие паттерны**: <a name="5"></a> описывают спопосбы эффективной коммуникации межлу объектами.
    * Chain of Responsibility - 
    * Command - 
    * Iterator - класс для обхода контейнера, который вынесен отдельно от самого контейнера. Позволяет создать одинаковый интерфейс обхода, для различных контейнеров.
    * Mediator (Посредник) - перенос зависимостей между объектами в отдельный класс "посредник", который будет знать кому нужно перенаправлять тот или иной запрос. Благодоря этому, компоненты системы будут зависить только от посредника, а не от других компонентов.
    * Memento (Снимок) -
    * Observer - 
    * State - 
    * Strategy - 
    * Template Method - 
    * Visitor -
* **Идиомы**: <a name="6"></a> Низкоуровневые паттерны, применимые в рамках одного языка программирования.
* **MVC**: <a name="7"></a>
    * Model - предоставляет данные и реагирует на команды контроллера, изменяя свое состояние.
    * View - отвечает за отображение данных модели пользователю, реагируя на изменения модели.
    * Controller - реагирует на действия пользователя, оповещая модель о необходимости изменения.
* **Внедрение зависимости (Dependency injection, DI)**: <a name="8"></a> это паттерн проектирования, который заключается в передаче зависимостей внешним образом, вместо того, чтобы объекты создавали свои зависимости самостоятельно. Суть DI заключается в том, что зависимости инъектируются в объекты извне, что делает объекты более гибкими, легкими в тестировании и снижает связанность между объектами.

В DI реализуется через конструкторы, методы или свойства объектов. Конструкторы - наиболее распространенный способ реализации DI, при котором зависимости передаются через параметры конструктора.
* **DRY**: <a name="9"></a>
* **data driving development**: <a name="10"></a>
* ****: <a name="11"></a>